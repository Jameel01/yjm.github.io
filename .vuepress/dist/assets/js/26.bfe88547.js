(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{317:function(t,a,e){"use strict";e.r(a);var s=e(0),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" React 渲染")]),t._v(" "),e("h2",{attrs:{id:"元素渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" 元素渲染")]),t._v(" "),e("p",[t._v("React元素是一个"),e("code",[t._v("不可变对象")]),t._v("，它代表某个特定时刻的UI，更新UI唯一的方式是创建一个全新的元素，并将其传入"),e("code",[t._v("ReactDOM.render(element, container[, callback])")]),t._v("中。")]),t._v(" "),e("ul",[e("li",[t._v("ReactDOM.render() 会控制你传入容器节点里的内容。当"),e("code",[t._v("首次调用")]),t._v("时，容器节点里的"),e("code",[t._v("所有 DOM 元素都会被替换")]),t._v("，"),e("code",[t._v("后续的调用")]),t._v("则会使用 React 的 DOM 差分算法（DOM diffing algorithm）进行高效的"),e("code",[t._v("更新")]),t._v("。")]),t._v(" "),e("li",[t._v("ReactDOM.render() 不会修改容器节点（只会修改容器的子节点）。可以在不覆盖现有子节点的情况下，将组件插入已有的 DOM 节点中。")]),t._v(" "),e("li",[t._v("ReactDOM.render() 目前会返回对根组件 "),e("code",[t._v("ReactComponent")]),t._v(" 实例的引用。 但是，目前应该避免使用返回的引用，因为它是历史遗留下来的内容，而且在未来版本的 React 中，组件渲染在某些情况下可能会是异步的。 如果你真的需要获得对根组件 "),e("code",[t._v("ReactComponent")]),t._v(" 实例的引用，那么推荐为根元素添加 "),e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("callback ref"),e("OutboundLink")],1),t._v("。")])]),t._v(" "),e("h2",{attrs:{id:"组件更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件更新","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件更新")]),t._v(" "),e("ol",[e("li",[t._v("在 "),e("code",[t._v("React.Component")]),t._v(" 的子类中有个必须定义的 "),e("code",[t._v("render()")]),t._v(" 函数")]),t._v(" "),e("li",[t._v("当组件的 "),e("code",[t._v("props")]),t._v(" 或 "),e("code",[t._v("state")]),t._v(" 发生变化时会触发更新")])]),t._v(" "),e("blockquote",[e("ul",[e("li",[t._v("static getDerivedStateFormProps()")]),t._v(" "),e("li",[t._v("shouldComponentUpdate()")]),t._v(" "),e("li",[t._v("render()")]),t._v(" "),e("li",[t._v("getSnapshotBeforeUpdate()")]),t._v(" "),e("li",[t._v("componentDidUpdate()")])])]),t._v(" "),e("h3",{attrs:{id:"可以在组件中调用的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以在组件中调用的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 可以在组件中调用的方法")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("component"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("forceUpdate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("调用 "),e("code",[t._v("forceUpdate()")]),t._v(" 将致使组件调用 "),e("code",[t._v("render()")]),t._v(" 方法，此操作会跳过该组件的 "),e("code",[t._v("shouldComponentUpdate()")]),t._v("。但其子组件会触发正常的生命周期方法，包括 "),e("code",[t._v("shouldComponentUpdate()")]),t._v(" 方法。如果标记发生变化，React 仍将只更新 DOM")]),t._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[t._v("通常应该避免使用 "),e("code",[t._v("forceUpdate()")]),t._v("，尽量在 render() 只使用 "),e("code",[t._v("this.props")]),t._v(" 和 "),e("code",[t._v("this.state")])])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("updater"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("将 "),e("code",[t._v("setState()")]),t._v(" 视为请求而不是立即更新组件的命令,"),e("code",[t._v("setState()")]),t._v(" 并不总是立即更新组件。它会批量推迟更新。这使得在调用 "),e("code",[t._v("setState()")]),t._v(" 后立即读取 "),e("code",[t._v("this.state")]),t._v(" 成为了隐患。为了消除隐患，请使用 "),e("code",[t._v("componentDidUpdate")]),t._v(" 或者 "),e("code",[t._v("setState")]),t._v(" 的回调函数（setState(updater, callback)），这两种方式都可以保证在应用更新后触发。如需基于之前的 "),e("code",[t._v("state")]),t._v(" 来设置当前的 "),e("code",[t._v("state，")])]),t._v(" "),e("ol",[e("li",[t._v("第一个参数")])]),t._v(" "),e("ul",[e("li",[t._v("对象形式（异步更改state）\n这种形式的 setState() 是异步的，并且在同一周期内会对多个 setState 进行批处理（后调用setState的值会覆盖同一周期内先调用 setState 的值）。")]),t._v(" "),e("li",[t._v("函数形式（同步更改state）")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" stateChange\n")])])]),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("counter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("counter "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" props"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("step"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("第二个参数：为可选的回调函数，它将在 setState 完成合并并重新渲染组件后执行。通常，建议使用 "),e("code",[t._v("componentDidUpdate()")]),t._v(" 来代替此方式。")])]),t._v(" "),e("h2",{attrs:{id:"redux-更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-更新","aria-hidden":"true"}},[t._v("#")]),t._v(" Redux 更新")])])}),[],!1,null,null,null);a.default=n.exports}}]);