(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{288:function(t,a,s){"use strict";s.r(a);var e=s(0),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"redux"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redux","aria-hidden":"true"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),s("h2",{attrs:{id:"词汇表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词汇表","aria-hidden":"true"}},[t._v("#")]),t._v(" 词汇表")]),t._v(" "),s("h3",{attrs:{id:"state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state","aria-hidden":"true"}},[t._v("#")]),t._v(" State")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type state "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" any\n")])])]),s("p",[t._v("State (也称为 state tree) 是一个宽泛的概念，但是在 Redux API 中，通常是指一个唯一的 state 值，由 store 管理且由 "),s("code",[t._v("getState()")]),t._v(" 方法获得。它表示了 Redux 应用的全部状态，通常为一个多层嵌套的对象。")]),t._v(" "),s("p",[t._v("约定俗成，顶层 state 或为一个对象，或像 Map 那样的键-值集合，也可以是任意的数据类型。然而你应尽可能确保 state 可以被序列化，而且不要把什么数据都放进去，导致无法轻松地把 state 转换成 JSON。")]),t._v(" "),s("h3",{attrs:{id:"action"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#action","aria-hidden":"true"}},[t._v("#")]),t._v(" Action")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type action "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object\n")])])]),s("p",[t._v("Action 是一个普通对象，用来表示即将改变 state 的意图。它是将数据放入 store 的唯一途径。无论是从 UI 事件、网络回调，还是其他诸如 WebSocket 之类的数据源所获得的数据，最终都会被 dispatch 成 action。")]),t._v(" "),s("p",[t._v("约定俗成，action 必须拥有一个 type 域，它指明了需要被执行的 action type。Type 可以被定义为常量，然后从其他 module 导入。比起用 Symbols 表示 type，使用 String 是更好的方法，因为 string 可以被序列化。")]),t._v(" "),s("p",[t._v("除了 type 之外，action 对象的结构其实完全取决于你自己。")]),t._v(" "),s("h3",{attrs:{id:"reducer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reducer","aria-hidden":"true"}},[t._v("#")]),t._v(" Reducer")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type Reducer"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("S")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("S")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" action"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("S")]),t._v("\n")])])]),s("p",[t._v("Reducer (也称为 "),s("em",[t._v("reducing function")]),t._v(") 函数接受两个参数：之前累积运算的结果和当前被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。")]),t._v(" "),s("p",[t._v("Reducer 并不是 Redux 特有的函数 —— 它是函数式编程中的一个基本概念，甚至大部分的非函数式语言比如 JavaScript，都有一个内置的 reduce API。对于 JavaScript，这个 API 是 "),s("code",[t._v("Array.prototype.reduce()")]),t._v(".")]),t._v(" "),s("p",[t._v("在 Redux 中，累计运算的结果是 state 对象，而被累积的值是 action。Reducer 由上次累积的结果 state 与当前被累积的 action 计算得到一个新 state。这些 Reducer "),s("strong",[t._v("必须是纯函数")]),t._v("，而且当输入相同时返回的结果也会相同。它们不应该产生任何副作用。正因如此，才使得诸如热重载和时间旅行这些很棒的功能成为可能。")]),t._v(" "),s("p",[t._v("Reducer 是 Redux 之中最重要的概念。")]),t._v(" "),s("p",[s("strong",[t._v("不要在 reducer 中有 API 调用")])]),t._v(" "),s("h3",{attrs:{id:"dispath-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dispath-函数","aria-hidden":"true"}},[t._v("#")]),t._v(" dispath 函数")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("BaseDispatch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Action")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Action\ntype "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Dispatch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Action "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" AsyncAction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" any\n")])])]),s("p",[t._v("dispatching function (或简言之 dispatch function) 是一个接收 action 或者异步 action的函数，该函数要么往 store 分发一个或多个 action，要么不分发任何 action。")]),t._v(" "),s("p",[t._v("我们必须分清一般的 dispatch function 以及由 store 实例提供的没有 middleware 的 base dispatch function 之间的区别。")]),t._v(" "),s("p",[t._v("Base dispatch function 总是同步地把 action 与上一次从 store 返回的 state 发往 reducer，然后计算出新的 state。它期望 action 会是一个可以被 reducer 消费的普通对象。")]),t._v(" "),s("p",[t._v("Middleware 封装了 base dispatch function，允许 dispatch function 处理 action 之外的异步 action。 Middleware 可以改变、延迟、忽略 action 或异步 action，也可以在传递给下一个 middleware 之前对它们进行解释。")]),t._v(" "),s("h3",{attrs:{id:"action-creator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#action-creator","aria-hidden":"true"}},[t._v("#")]),t._v(" Action Creator")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("ActionCreator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Action "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" AsyncAction\n")])])]),s("p",[t._v("Action Creator 很简单，就是一个创建 action 的函数。不要混淆 action 和 action creator 这两个概念。Action 是一个信息的负载，而 action creator 是一个创建 action 的工厂。")]),t._v(" "),s("p",[t._v("调用 action creator 只会生产 action，但不分发。你需要调用 store 的 dispatch function 才会引起变化。有时我们讲 bound action creator，是指一个函数调用了 action creator 并立即将结果分发给一个特定的 store 实例。")]),t._v(" "),s("p",[t._v("如果 action creator 需要读取当前的 state、调用 API、或引起诸如路由变化等副作用，那么它应该返回一个异步 action而不是 action。")]),t._v(" "),s("h3",{attrs:{id:"异步action"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步action","aria-hidden":"true"}},[t._v("#")]),t._v(" 异步Action")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type AsyncAction "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" any\n")])])]),s("p",[t._v("异步 action 是一个发给 dispatching 函数的值，但是这个值还不能被 reducer 消费。在发往 base dispatch() function 之前，middleware 会把异步 action 转换成一个或一组 action。异步 action 可以有多种 type，这取决于你所使用的 middleware。它通常是 Promise 或者 thunk 之类的异步原生数据类型，虽然不会立即把数据传递给 reducer，但是一旦操作完成就会触发 action 的分发事件。")]),t._v(" "),s("h3",{attrs:{id:"middleware"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#middleware","aria-hidden":"true"}},[t._v("#")]),t._v(" Middleware")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type MiddlewareAPI "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" dispatch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Dispatch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" State "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\ntype "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Middleware")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("api"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" MiddlewareAPI")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Dispatch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Dispatch\n")])])]),s("p",[t._v("Middleware 是一个组合 dispatch function 的高阶函数，返回一个新的 dispatch function，通常将异步 actions 转换成 action。")]),t._v(" "),s("p",[t._v("Middleware 利用复合函数使其可以组合其他函数，可用于记录 action 日志、产生其他诸如变化路由的副作用，或将异步的 API 调用变为一组同步的 action。")]),t._v(" "),s("h3",{attrs:{id:"store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#store","aria-hidden":"true"}},[t._v("#")]),t._v(" Store")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type Store "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  dispatch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Dispatch\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" State\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("subscribe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("listener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("replaceReducer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("reducer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Reducer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Store 维持着应用的 state tree 对象。 因为应用的构建发生于 reducer，所以一个 Redux 应用中应当只有一个 Store。")]),t._v(" "),s("ul",[s("li",[t._v("dispatch(action) 是上述的 base dispatch function。")]),t._v(" "),s("li",[t._v("getState() 返回当前 store 的 state。")]),t._v(" "),s("li",[t._v("subscribe(listener) 注册一个 state 发生变化时的回调函数。")]),t._v(" "),s("li",[t._v("replaceReducer(nextReducer) 可用于热重载和代码分割。通常你不需要用到这个 API。")])]),t._v(" "),s("h3",{attrs:{id:"store-creator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#store-creator","aria-hidden":"true"}},[t._v("#")]),t._v(" Store Creator")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("StoreCreator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("reducer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Reducer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" initialState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("State")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Store\n")])])]),s("p",[t._v("Store creator 是一个创建 Redux store 的函数。就像 dispatching function 那样，我们必须分清通过 createStore(reducer, initialState) 由 Redux 导出的 base store creator 与从 store enhancer 返回的 store creator 之间的区别。")]),t._v(" "),s("h3",{attrs:{id:"store-enhancer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#store-enhancer","aria-hidden":"true"}},[t._v("#")]),t._v(" Store enhancer")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("type "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("StoreEnhancer")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" StoreCreator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" StoreCreator\n")])])]),s("p",[t._v("Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。")]),t._v(" "),s("p",[t._v("Store enhancer 与 React 的高阶 component 概念一致，通常也会称为 “component enhancers”。")]),t._v(" "),s("p",[t._v("因为 store 并非实例，更像是一个函数集合的普通对象，所以可以轻松地创建副本，也可以在不改变原先的 store 的条件下修改副本。在 compose 文档中有一个示例演示了这种做法。")]),t._v(" "),s("p",[t._v("大多数时候你基本不用编写 store enhancer，但你可能会在 developer tools 中用到。正因为 store enhancer，应用程序才有可能察觉不到“时间旅行”。有趣的是，Redux middleware 本身的实现就是一个 store enhancer。")])])}),[],!1,null,null,null);a.default=r.exports}}]);